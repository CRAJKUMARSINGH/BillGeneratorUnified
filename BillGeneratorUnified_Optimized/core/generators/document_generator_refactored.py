import os
import logging
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass
from pathlib import Path
import time
from abc import ABC, abstractmethod

from utils.memory_manager import get_memory_manager
from utils.cache_manager import get_cache_manager
from utils.error_handler import get_error_handler, handle_errors

@dataclass
class DocumentConfig:
    output_dir: str = "output"
    template_dir: str = "templates"
    cache_enabled: bool = True
    compression_enabled: bool = True
    max_file_size: int = 50 * 1024 * 1024  # 50MB

@dataclass
class DocumentRequest:
    template_name: str
    data: Dict[str, Any]
    output_filename: str
    format: str = "pdf"  # pdf, docx, html
    metadata: Dict[str, Any] = None

@dataclass
class DocumentResult:
    success: bool
    output_path: str
    file_size: int
    generation_time: float
    error_message: str = ""
    metadata: Dict[str, Any] = None

class DocumentTemplate(ABC):
    """Abstract base class for document templates"""
    
    @abstractmethod
    def render(self, data: Dict[str, Any]) -> str:
        """Render template with data"""
        pass
        
    @abstractmethod
    def get_template_info(self) -> Dict[str, Any]:
        """Get template information"""
        pass

class PDFDocumentTemplate(DocumentTemplate):
    """PDF document template implementation"""
    
    def __init__(self, template_path: str):
        self.template_path = Path(template_path)
        self.logger = logging.getLogger(__name__)
        
    def render(self, data: Dict[str, Any]) -> str:
        """Render PDF document"""
        try:
            # This would integrate with a PDF library like ReportLab
            # For now, return a simple HTML representation
            html_content = self._generate_html(data)
            return html_content
            
        except Exception as e:
            self.logger.error(f"PDF template render error: {e}")
            raise
            
    def _generate_html(self, data: Dict[str, Any]) -> str:
        """Generate HTML from data"""
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Document</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .header {{ border-bottom: 2px solid #333; padding-bottom: 10px; }}
                .content {{ margin: 20px 0; }}
                .footer {{ border-top: 1px solid #ccc; padding-top: 10px; font-size: 12px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>{data.get('title', 'Document')}</h1>
                <p>Date: {data.get('date', time.strftime('%Y-%m-%d'))}</p>
            </div>
            
            <div class="content">
                {self._render_content(data)}
            </div>
            
            <div class="footer">
                <p>Generated by BillGeneratorUnified</p>
            </div>
        </body>
        </html>
        """
        return html
        
    def _render_content(self, data: Dict[str, Any]) -> str:
        """Render main content"""
        content = ""
        
        if 'items' in data:
            content += "<h2>Items</h2><table border='1' style='width: 100%; border-collapse: collapse;'>"
            content += "<tr><th>Description</th><th>Quantity</th><th>Price</th><th>Total</th></tr>"
            
            for item in data['items']:
                total = item.get('quantity', 0) * item.get('price', 0)
                content += f"""
                <tr>
                    <td>{item.get('description', '')}</td>
                    <td>{item.get('quantity', 0)}</td>
                    <td>${item.get('price', 0):.2f}</td>
                    <td>${total:.2f}</td>
                </tr>
                """
                
            content += "</table>"
            
        if 'total_amount' in data:
            content += f"<h3>Total Amount: ${data['total_amount']:.2f}</h3>"
            
        return content
        
    def get_template_info(self) -> Dict[str, Any]:
        """Get template information"""
        return {
            'template_type': 'PDF',
            'template_path': str(self.template_path),
            'supported_formats': ['pdf', 'html'],
            'features': ['tables', 'headers', 'footers', 'styling']
        }

class DocumentGeneratorRefactored:
    """Refactored document generator with clean architecture"""
    
    def __init__(self, config: DocumentConfig = None):
        self.config = config or DocumentConfig()
        self.memory_manager = get_memory_manager()
        self.cache_manager = get_cache_manager()
        self.error_handler = get_error_handler()
        
        self.logger = logging.getLogger(__name__)
        
        # Template registry
        self.templates: Dict[str, DocumentTemplate] = {}
        
        # Statistics
        self.stats = {
            'documents_generated': 0,
            'total_generation_time': 0.0,
            'cache_hits': 0,
            'errors': 0
        }
        
        # Initialize templates
        self._initialize_templates()
        
    def _initialize_templates(self):
        """Initialize document templates"""
        try:
            # Register default PDF template
            pdf_template = PDFDocumentTemplate("default_pdf")
            self.templates["pdf"] = pdf_template
            self.templates["default"] = pdf_template
            
            self.logger.info("Document templates initialized")
            
        except Exception as e:
            self.logger.error(f"Template initialization error: {e}")
            
    def register_template(self, name: str, template: DocumentTemplate):
        """Register a new document template"""
        self.templates[name] = template
        self.logger.info(f"Template registered: {name}")
        
    @handle_errors(category="PROCESSING")
    def generate_document(self, request: DocumentRequest) -> DocumentResult:
        """Generate document from request"""
        start_time = time.time()
        
        try:
            # Validate request
            self._validate_request(request)
            
            # Check cache
            cache_key = self._generate_cache_key(request)
            if self.config.cache_enabled:
                cached_result = self.cache_manager.get(cache_key, "documents")
                if cached_result:
                    self.stats['cache_hits'] += 1
                    self.logger.debug(f"Document cache hit: {request.output_filename}")
                    return cached_result
                    
            # Get template
            template = self._get_template(request.template_name)
            
            # Render document
            rendered_content = template.render(request.data)
            
            # Convert to requested format
            output_path = self._convert_to_format(
                rendered_content, request.format, request.output_filename
            )
            
            # Create result
            generation_time = time.time() - start_time
            result = DocumentResult(
                success=True,
                output_path=output_path,
                file_size=Path(output_path).stat().st_size,
                generation_time=generation_time,
                metadata=request.metadata or {}
            )
            
            # Cache result
            if self.config.cache_enabled:
                self.cache_manager.set(cache_key, result, "documents")
                
            # Update statistics
            self.stats['documents_generated'] += 1
            self.stats['total_generation_time'] += generation_time
            
            self.logger.info(f"Document generated: {request.output_filename} "
                           f"({generation_time:.2f}s)")
            
            return result
            
        except Exception as e:
            generation_time = time.time() - start_time
            self.stats['errors'] += 1
            
            error_result = DocumentResult(
                success=False,
                output_path="",
                file_size=0,
                generation_time=generation_time,
                error_message=str(e)
            )
            
            self.logger.error(f"Document generation failed: {request.output_filename} - {e}")
            return error_result
            
    def _validate_request(self, request: DocumentRequest):
        """Validate document request"""
        if not request.template_name:
            raise ValueError("Template name is required")
            
        if not request.output_filename:
            raise ValueError("Output filename is required")
            
        if not request.data:
            raise ValueError("Data is required")
            
        if request.format not in ['pdf', 'docx', 'html']:
            raise ValueError(f"Unsupported format: {request.format}")
            
    def _get_template(self, template_name: str) -> DocumentTemplate:
        """Get document template"""
        if template_name not in self.templates:
            # Fall back to default template
            if 'default' in self.templates:
                template_name = 'default'
            else:
                raise ValueError(f"Template not found: {template_name}")
                
        return self.templates[template_name]
        
    def _generate_cache_key(self, request: DocumentRequest) -> str:
        """Generate cache key for request"""
        import hashlib
        import json
        
        # Create a deterministic string from request
        key_data = {
            'template_name': request.template_name,
            'data': request.data,
            'format': request.format
        }
        
        key_string = json.dumps(key_data, sort_keys=True)
        return hashlib.md5(key_string.encode()).hexdigest()
        
    def _convert_to_format(self, content: str, format_type: str, 
                          filename: str) -> str:
        """Convert content to specified format"""
        output_dir = Path(self.config.output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        output_path = output_dir / f"{filename}.{format_type}"
        
        if format_type == 'html':
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
        elif format_type == 'pdf':
            # This would use a PDF library like WeasyPrint or ReportLab
            # For now, save as HTML with .pdf extension
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
        elif format_type == 'docx':
            # This would use python-docx library
            # For now, save as HTML with .docx extension
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
        else:
            raise ValueError(f"Unsupported format: {format_type}")
            
        return str(output_path)
        
    def generate_batch(self, requests: List[DocumentRequest]) -> List[DocumentResult]:
        """Generate multiple documents"""
        results = []
        
        for request in requests:
            result = self.generate_document(request)
            results.append(result)
            
        return results
        
    def get_template_info(self, template_name: str = None) -> Union[Dict[str, Any], List[Dict[str, Any]]]:
        """Get template information"""
        if template_name:
            if template_name in self.templates:
                return self.templates[template_name].get_template_info()
            else:
                raise ValueError(f"Template not found: {template_name}")
        else:
            return [
                {**template.get_template_info(), 'name': name}
                for name, template in self.templates.items()
            ]
            
    def get_statistics(self) -> Dict[str, Any]:
        """Get generation statistics"""
        total_docs = self.stats['documents_generated']
        
        return {
            'documents_generated': total_docs,
            'total_generation_time': self.stats['total_generation_time'],
            'average_generation_time': (
                self.stats['total_generation_time'] / total_docs
                if total_docs > 0 else 0
            ),
            'cache_hits': self.stats['cache_hits'],
            'cache_hit_rate': (
                (self.stats['cache_hits'] / total_docs) * 100
                if total_docs > 0 else 0
            ),
            'errors': self.stats['errors'],
            'error_rate': (
                (self.stats['errors'] / total_docs) * 100
                if total_docs > 0 else 0
            ),
            'registered_templates': len(self.templates)
        }
        
    def clear_cache(self):
        """Clear document cache"""
        self.cache_manager.clear("documents")
        self.logger.info("Document cache cleared")
        
    def cleanup_old_documents(self, max_age_hours: int = 24):
        """Clean up old generated documents"""
        output_dir = Path(self.config.output_dir)
        current_time = time.time()
        max_age_seconds = max_age_hours * 3600
        
        cleaned_count = 0
        
        for file_path in output_dir.glob("*"):
            if file_path.is_file():
                file_age = current_time - file_path.stat().st_mtime
                if file_age > max_age_seconds:
                    try:
                        file_path.unlink()
                        cleaned_count += 1
                    except Exception as e:
                        self.logger.error(f"Error cleaning up file {file_path}: {e}")
                        
        if cleaned_count > 0:
            self.logger.info(f"Cleaned up {cleaned_count} old documents")

# Global document generator instance
document_generator = DocumentGeneratorRefactored()

def get_document_generator() -> DocumentGeneratorRefactored:
    """Get the global document generator instance"""
    return document_generator